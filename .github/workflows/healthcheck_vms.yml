# Regularly updates the CI container
name: Reboots VMs in a controlled way
on:
  push:

jobs:
  pre-flight:
    runs-on: ubuntu-latest
    outputs:
      list-of-vms: ${{ steps.main.outputs.main }}
    environment: main
    steps:
      - name: Get list of VMs
        id: main
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        run: |
          # Hardcoded for testing purposes
          MATRIX='[{"vm": "azure-gpu-vm-runner2"}]'
          echo "Using hardcoded test runner: $MATRIX"
          echo main=$MATRIX | tee -a "$GITHUB_OUTPUT"

  healthcheck:
    needs: pre-flight
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.pre-flight.outputs.list-of-vms )}}
    uses: ./.github/workflows/_healthcheck_vm.yml
    with:
      vm: ${{ matrix.vm }}
      n_gpus: "2"
    secrets:
      SLACK_WEBHOOK_ADMIN: ${{ secrets.SLACK_WEBHOOK_ADMIN }}
      SLACK_RELEASE_ENDPOINT: ${{ secrets.SLACK_RELEASE_ENDPOINT }}
      VM_KEY: ${{ secrets.VM_KEY }}
      PAT: ${{ secrets.PAT }}

  check-offline-runners:
    needs: healthcheck
    if: ${{ always() }}
    runs-on: ubuntu-latest
    environment: main
    outputs:
      has_offline: ${{ steps.check.outputs.has_offline }}
    steps:
      - name: Check if any runners are offline
        id: check
        env:
          GITHUB_TOKEN: ${{ secrets.PAT }}
        run: |
          # Debug: Check if token is available
          if [[ -z "$GITHUB_TOKEN" ]]; then
            echo "ERROR: GITHUB_TOKEN is empty - PAT secret may not be configured"
            exit 1
          fi

          echo "Fetching runners from GitHub API..."
          RUNNERS=$(curl -L \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            ${{ github.api_url }}/repos/${{ github.repository }}/actions/runners)

          # Debug: Check API response
          if [[ -z "$RUNNERS" || "$RUNNERS" == "null" ]]; then
            echo "ERROR: API response is empty or null"
            echo "Response: $RUNNERS"
            exit 1
          fi

          echo "API response received, checking for offline runners..."
          OFFLINE_COUNT=$(echo "$RUNNERS" | jq -r '[.runners[]? | select(.status == "offline")] | length')

          if [[ "$OFFLINE_COUNT" == "null" || -z "$OFFLINE_COUNT" ]]; then
            echo "WARNING: Could not parse offline count, assuming no offline runners"
            OFFLINE_COUNT=0
          fi

          if [[ $OFFLINE_COUNT -gt 0 ]]; then
            echo "Found $OFFLINE_COUNT offline runners"
            echo "has_offline=true" >> "$GITHUB_OUTPUT"
          else
            echo "All runners are online (checked $OFFLINE_COUNT offline)"
            echo "has_offline=false" >> "$GITHUB_OUTPUT"
          fi

  wait-for-reboot:
    needs: check-offline-runners
    if: ${{ needs.check-offline-runners.outputs.has_offline == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Wait for VMs to come back online
        run: |
          WAIT_MINUTES=5
          echo "Waiting ${WAIT_MINUTES} minutes for rebooted VMs to come back online..."
          sleep $((WAIT_MINUTES * 60))

  recheck:
    needs: [pre-flight, wait-for-reboot]
    if: ${{ always() && needs.wait-for-reboot.result == 'success' }}
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJSON(needs.pre-flight.outputs.list-of-vms )}}
    uses: ./.github/workflows/_healthcheck_vm.yml
    with:
      vm: ${{ matrix.vm }}
      n_gpus: "2"
      is_recheck: true
    secrets:
      SLACK_WEBHOOK_ADMIN: ${{ secrets.SLACK_WEBHOOK_ADMIN }}
      SLACK_RELEASE_ENDPOINT: ${{ secrets.SLACK_RELEASE_ENDPOINT }}
      VM_KEY: ${{ secrets.VM_KEY }}
      PAT: ${{ secrets.PAT }}
