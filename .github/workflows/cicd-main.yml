# Copyright (c) 2025, NVIDIA CORPORATION.  All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
name: "CICD NeMo RL"

on:
  pull_request:
    branches:
      - "main"
      - "r**"
    types: [labeled, opened, synchronize, reopened]
  merge_group:
    types: [checks_requested]
  workflow_dispatch:
    inputs:
      test_to_run:
        required: false
        default: L2
        type: choice
        options:
          - docs
          - L0
          - L1
          - L2
        description: Test level to run. docs = doc tests only, L0 = unit/docs/lint, L1 = L0 + functional, L2 = L1 + convergence
  # TODO: Due to limited compute, disabling pushes to main. This is okay to do since we force PRs to be up to date and the CI tests on pull/$PR_NUM/merge
  #push:
  #  branches:
  #    - 'main'

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}-${{ github.event.label.name || 'main' }}
  cancel-in-progress: true

jobs:
  pre-flight:
    runs-on: ubuntu-latest
    outputs:
      test_level: ${{ steps.evaluate.outputs.test_level }}
    steps:
      - name: Get changed files
        id: changed-files
        if: github.event_name == 'pull_request'
        uses: step-security/changed-files@v45.0.1
        with:
          files_yaml: |
            doc:
              - '**.md'
              - docs/**
            src:
              - '!**.md'
              - '!docs/**'

      - name: Evaluate conditions
        id: evaluate
        env:
          DOCS_ONLY: ${{ steps.changed-files.outputs.doc_any_changed == 'true' && steps.changed-files.outputs.src_any_changed == 'false' }}
          CHANGED_DOCS: ${{ steps.changed-files.outputs.doc_all_changed_files }}
          CHANGED_SRC: ${{ steps.changed-files.outputs.src_all_changed_files }}
          IS_PULLREQUEST: ${{ github.event_name == 'pull_request' }}
          LABEL: ${{ github.event.label.name }}
          MERGE_GROUP: ${{ github.event_name == 'merge_group' }}
        run: |
          # Some output that's helpful for debugging
          echo "Docs changed: $CHANGED_DOCS"
          echo "Src changed: $CHANGED_SRC"
          echo "LABEL: $LABEL"
          echo "IS_PULLREQUEST: $IS_PULLREQUEST"
          echo "DOCS_ONLY: $DOCS_ONLY"

          # Run CI only (on main or if label is attached) and if it's not only docs
          # Determine test level based on conditions
          if [[ "$DOCS_ONLY" == "true" || "$LABEL" == "CI:docs" ]]; then
            # For doc-only changes, run only doc tests
            TEST_LEVEL="docs"
          elif [[ "$LABEL" == "CI:L0" ]]; then
            TEST_LEVEL="L0"
          elif [[ "$LABEL" == "CI:L1" || "$IS_PULLREQUEST" == "false" || "$MERGE_GROUP" == "true"  ]]; then
            # For labeled PRs, pushes to main (IS_PULL_REQUEST=false), or merge group events, run L1 by default
            TEST_LEVEL="L1"
          elif [[ "$LABEL" == "CI:L2" ]]; then
            TEST_LEVEL="L2"
          else
            # Skip tests by default for non-labeled PRs
            TEST_LEVEL="none"
          fi

          # Override test level if specified in workflow_dispatch
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Overriding test level from $TEST_LEVEL to ${{ inputs.test_to_run }}"
            TEST_LEVEL="${{ inputs.test_to_run }}"
          fi

          echo "test_level=$TEST_LEVEL" | tee -a "$GITHUB_OUTPUT"

  submodule-check:
    name: Check submodule fast-forward
    needs: [pre-flight]
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: 'recursive'
      
      - name: Fetch target branch reference
        run: |
          git fetch origin ${{ github.base_ref }}
      
      - name: Check submodule fast-forward status
        shell: bash -x -e {0}
        run: |
          echo "Checking submodules are fast-forwarded..."
          
          # Get current submodule status
          echo "Current submodule status:"
          git submodule status
          
          failed=0
          
          # Process each submodule from git submodule status
          while read -r line; do
            # Extract commit and path from: " <commit> <path> (<branch_info>)"
            current_commit=$(echo "$line" | awk '{print $1}' | sed 's/^[+-]//')
            submodule_path=$(echo "$line" | awk '{print $2}')
            
            if [[ -z "$current_commit" ]] || [[ -z "$submodule_path" ]]; then
              continue
            fi
            
            submodule_name=$(basename "$submodule_path")
            echo ""
            echo "Checking $submodule_name at $submodule_path"
            echo "Current commit: $current_commit"
            
            # Get target branch commit for this submodule
            target_commit=$(git ls-tree origin/${{ github.base_ref }} "$submodule_path" | awk '{print $3}')
            
            if [[ -z "$target_commit" ]]; then
              echo "âŒ Could not find $submodule_name in target branch"
              failed=1
              continue
            fi
            
            echo "Target commit:  $target_commit"
            
            # Analyze the relationship between target and current commits
            cd "$submodule_path"
            
            # Check if this is a shallow repository and unshallow if needed
            if git rev-parse --is-shallow-repository >/dev/null 2>&1 && [ "$(git rev-parse --is-shallow-repository)" = "true" ]; then
              echo "ðŸ“¦ $submodule_name: Detected shallow clone, fetching full history..."
              git fetch --unshallow >/dev/null 2>&1 || {
                echo "âš ï¸  Warning: Failed to unshallow repository. Ancestry checks may be limited."
              }
            fi
            
            # Case 1: Same commit
            if [[ "$current_commit" = "$target_commit" ]]; then
              echo "âœ… $submodule_name: Same commit as target branch"
              
            # Case 2: Check if target commit is an ancestor of current commit (current is fast-forward)
            elif git merge-base --is-ancestor "$target_commit" "$current_commit" 2>/dev/null; then
              echo "âœ… $submodule_name: Current commit is a fast-forward of target branch"
              echo "ðŸ“Š Commits added since target branch:"
              git log --oneline --graph "$target_commit".."$current_commit" 2>/dev/null || echo "   (Unable to show progression - possibly shallow clone)"
              
            # Case 3: Check if current commit is an ancestor of target commit (current is behind)
            elif git merge-base --is-ancestor "$current_commit" "$target_commit" 2>/dev/null; then
              echo "âŒ $submodule_name: Current commit is BEHIND target branch"
              echo "   Current commit is an ancestor of target - submodule needs to be updated forward"
              echo "ðŸ“Š Missing commits that should be included:"
              git log --oneline --graph "$current_commit".."$target_commit" 2>/dev/null || echo "   (Unable to show missing commits)"
              failed=1
              
            else
              # Case 4: Commits have diverged or have no common ancestor
              common_ancestor=$(git merge-base "$target_commit" "$current_commit" 2>/dev/null)
              
              if [ -n "$common_ancestor" ]; then
                echo "âŒ $submodule_name: Commits have DIVERGED from a common ancestor"
                echo "   This indicates parallel development - manual merge may be required"
                echo ""
                echo "ðŸ“Š Divergence analysis:"
                echo "   Common ancestor: $common_ancestor"
                git log --oneline -1 "$common_ancestor" 2>/dev/null || echo "   (Unable to show common ancestor)"
                echo ""
                echo "   For detailed commit history inspection:"
                
                # Get GitHub repository URL dynamically from git remote
                remote_url=$(git remote get-url origin 2>/dev/null || echo "")
                if [[ "$remote_url" == *.git ]]; then
                  github_repo="${remote_url%.git}"
                else
                  github_repo="$remote_url"
                fi
                
                if [[ -n "$github_repo" && "$github_repo" == https://github.com/* ]]; then
                  echo "   TARGET commit history:  $github_repo/commits/$target_commit/"
                  echo "   CURRENT commit history: $github_repo/commits/$current_commit/"
                else
                  echo "   Repository: $github_repo (unable to generate GitHub URLs)"
                  echo "   TARGET commit: $target_commit"
                  echo "   CURRENT commit: $current_commit"
                fi
              else
                echo "âŒ $submodule_name: Commits have NO COMMON ANCESTOR"
                echo "   This indicates commits are from completely different repositories or history"
                echo ""
                echo "ðŸ“Š For detailed commit inspection:"
                
                # Get GitHub repository URL dynamically from git remote
                remote_url=$(git remote get-url origin 2>/dev/null || echo "")
                if [[ "$remote_url" == *.git ]]; then
                  github_repo="${remote_url%.git}"
                else
                  github_repo="$remote_url"
                fi
                
                if [[ -n "$github_repo" && "$github_repo" == https://github.com/* ]]; then
                  echo "   TARGET commit:  $github_repo/commits/$target_commit/"
                  echo "   CURRENT commit: $github_repo/commits/$current_commit/"
                else
                  echo "   Repository: $github_repo (unable to generate GitHub URLs)"
                  echo "   TARGET commit: $target_commit"
                  echo "   CURRENT commit: $current_commit"
                fi
              fi
              
              failed=1
            fi
            cd "$GITHUB_WORKSPACE"
            
          done < <(git submodule status)
          
          if [[ $failed -eq 1 ]]; then
            echo ""
            echo "âŒ One or more submodules are not fast-forwarded"
            echo "Please ensure submodule commits are fast-forwards of the target branch"
            exit 1
          fi
          
          echo ""
          echo "âœ… All submodules are properly fast-forwarded"

  #lint-check:
  #  name: Lint check
  #  needs: [pre-flight]
  #  runs-on: ubuntu-latest
  #  steps:
  #    - name: Checkout repository
  #      uses: actions/checkout@v4
  #      with:
  #        submodules: 'recursive'
  #    - name: Install uv
  #      uses: astral-sh/setup-uv@v5
  #      with:
  #        version: "0.7.2"
  #        enable-cache: true
  #        prune-cache: false
  #    # Faster than uv python install since it caches python alongside runner
  #    - name: "Set up Python"
  #      uses: actions/setup-python@v5
  #      with:
  #        python-version-file: ".python-version"
  #    - name: Check lint
  #      run: |
  #        uv venv
  #        uv run --group dev pre-commit install
  #        uv run --group dev pre-commit run --all-files --show-diff-on-failure --color=always
  #    - name: Minimize uv cache
  #      run: uv cache prune --ci

  #mypy-check:
  #  name: Mypy check
  #  needs: [pre-flight]
  #  runs-on: ubuntu-latest
  #  steps:
  #    - name: Checkout repository
  #      uses: actions/checkout@v4
  #    - name: Install uv
  #      uses: astral-sh/setup-uv@v5
  #      with:
  #        version: "0.7.2"
  #        enable-cache: true
  #        prune-cache: false
  #    # Faster than uv python install since it caches python alongside runner
  #    - name: "Set up Python"
  #      uses: actions/setup-python@v5
  #      with:
  #        python-version-file: ".python-version"
  #    - name: Check mypy
  #      run: |
  #        uv venv
  #        uv run --group test mypy nemo_rl examples
  #    - name: Minimize uv cache
  #      run: uv cache prune --ci

  #sphinx-build:
  #  if: ${{ needs.pre-flight.outputs.test_level != 'none' }}
  #  name: Sphinx build
  #  needs: [pre-flight]
  #  runs-on: ubuntu-latest
  #  steps:
  #    - name: Checkout repository
  #      uses: actions/checkout@v4
  #      with:
  #        submodules: 'recursive'
  #    - name: Install uv
  #      uses: astral-sh/setup-uv@v5
  #      with:
  #        version: "0.7.2"
  #        enable-cache: true
  #        prune-cache: false
  #    # Faster than uv python install since it caches python alongside runner
  #    - name: "Set up Python"
  #      uses: actions/setup-python@v5
  #      with:
  #        python-version-file: ".python-version"
  #    - name: build docs
  #      run: |
  #        uv venv
  #        cd docs/
  #        uv run --group docs sphinx-build --fail-on-warning --builder html . _build/html
  #    - name: Minimize uv cache
  #      run: uv cache prune --ci

  #build-container:
  #  if: ${{ needs.pre-flight.outputs.test_level != 'none' }}
  #  needs: [pre-flight]
  #  uses: NVIDIA-NeMo/FW-CI-templates/.github/workflows/_build_container.yml@v0.30.0
  #  with:
  #    build-ref: ${{ github.sha }}
  #    image-name: nemo_rl_container
  #    dockerfile: docker/Dockerfile
  #    image-label: nemo-rl
  #    target: hermetic
  #    build-args: |
  #      MAX_JOBS=32
  #      NEMO_RL_COMMIT=${{ github.sha }}

  #tests:
  #  name: Tests
  #  needs: [build-container, pre-flight]
  #  uses: ./.github/workflows/_run_test.yml
  #  if: ${{ needs.pre-flight.outputs.test_level != 'none' }}
  #  with:
  #    RUNNER: self-hosted-azure
  #    TIMEOUT: 180
  #    UNIT_TEST_SCRIPT: |
  #      cd /opt/nemo-rl
  #      if [[ "${{ needs.pre-flight.outputs.test_level }}" =~ ^(L0|L1|L2)$ ]]; then
  #        uv run --no-sync bash -x ./tests/run_unit.sh --cov=nemo_rl --cov-report=term-missing --cov-report=json -m \"not mcore\"
  #        uv run --extra mcore bash -x ./tests/run_unit.sh --cov=nemo_rl --cov-report=term-missing --cov-report=json  -m mcore
  #      else
  #        echo Skipping unit tests for docs-only level
  #      fi
  #    DOC_TEST_SCRIPT: |
  #      cd /opt/nemo-rl/docs
  #      if [[ "${{ needs.pre-flight.outputs.test_level }}" =~ ^(docs|L0|L1|L2)$ ]]; then
  #        uv run --no-sync sphinx-build -b doctest . _build/doctest
  #      else
  #        echo Skipping doc tests for level ${{ needs.pre-flight.outputs.test_level }}
  #      fi
  #    FUNCTIONAL_TEST_SCRIPT: |
  #      cd /opt/nemo-rl
  #      if [[ "${{ needs.pre-flight.outputs.test_level }}" =~ ^(L1|L2)$ ]]; then
  #        time uv run --no-sync bash ./tests/functional/sft.sh
  #        time uv run --no-sync bash ./tests/functional/grpo.sh
  #        time uv run --no-sync bash ./tests/functional/grpo_megatron.sh
  #        time uv run --no-sync bash ./tests/functional/grpo_multiturn.sh
  #        time uv run --no-sync bash ./tests/functional/grpo_non_colocated.sh
  #        time uv run --no-sync bash ./tests/functional/dpo.sh
  #        time uv run --no-sync bash ./tests/functional/eval.sh
  #        time uv run --no-sync bash ./tests/functional/eval_async.sh
  #        time uv run --no-sync bash ./tests/functional/test_mcore_extra_installed_correctly.sh
  #      else
  #        echo Skipping functional tests for level ${{ needs.pre-flight.outputs.test_level }}
  #      fi
  #    # TODO: enable once we have convergence tests in CI
  #    #CONVERGENCE_TEST_SCRIPT: |
  #    #  cd /opt/nemo-rl
  #    #  if [[ "${{ needs.pre-flight.outputs.test_level }}" =~ ^(L2)$  ]]; then
  #    #    echo "Running convergence tests"
  #    #    # Add your convergence test commands here
  #    #    # uv run --no-sync bash ./tests/convergence/test.sh
  #    #  else
  #    #    echo "Skipping convergence tests for level ${{ needs.pre-flight.outputs.test_level }}"
  #    #  fi
  #    AFTER_SCRIPT: |
  #      cd /opt/nemo-rl
  #      cat <<EOF | tee -a $GITHUB_STEP_SUMMARY
  #      # Test Summary for level: ${{ needs.pre-flight.outputs.test_level }}

  #      ## Unit test results
  #      \`\`\`json
  #      $(if [[ "${{ needs.pre-flight.outputs.test_level }}" =~ ^(L0|L1|L2)$ ]]; then cat tests/unit/unit_results.json || echo "n/a"; else echo "Not run"; fi)
  #      \`\`\`

  #      ## Test Level: ${{ needs.pre-flight.outputs.test_level }}
  #      EOF
  #  secrets:
  #    HF_TOKEN: ${{ secrets.HF_TOKEN }}

  #coverage:
  #  name: Upload coverage to Codecov
  #  needs: [tests]
  #  if: ${{ contains('L0 L1 L2', needs.pre-flight.outputs.test_level) }}
  #  runs-on: ubuntu-latest
  #  steps:
  #    - name: Checkout repository
  #      uses: actions/checkout@v4

  #    - name: Download coverage artifact
  #      uses: actions/download-artifact@v4
  #      with:
  #        name: unit-test-coverage-report
  #        path: .

  #    - name: Upload to Codecov
  #      uses: codecov/codecov-action@v4
  #      with:
  #        token: ${{ secrets.CODECOV_TOKEN }}
  #        file: ./coverage.json
  #        flags: unit-tests
  #        verbose: true
  #        override_branch: ${{ github.event_name == 'merge_group' && 'main' || '' }}

  #CI_QA_Gate:
  #  name: CI quality check
  #  if: always()
  #  runs-on: ubuntu-latest
  #  needs:
  #    - pre-flight
  #    - lint-check
  #    - sphinx-build
  #    - tests
  #  steps:
  #    - name: main
  #      env:
  #        JOB_RESULTS: ${{ toJSON(needs) }}
  #        # Job is considered successful if nothing was run, or if all jobs were successful (the tests run even if only docs were run b/c doctests are selected)
  #        ALL_SUCCESS: >-
  #          ${{
  #            needs.lint-check.result == 'success' &&
  #            (
  #              needs.pre-flight.outputs.test_level == 'none' ||
  #              (
  #                needs.pre-flight.outputs.test_level != 'none' &&
  #                needs.sphinx-build.result == 'success' &&
  #                needs.tests.result == 'success' &&
  #                (needs.mypy-check.result == 'success' || true)
  #              )
  #            )
  #          }}
  #        CI_SKIP: ${{ github.event.label.name == 'Skip CICD' }}
  #        TEST_LEVEL: ${{ needs.pre-flight.outputs.test_level }}
  #      run: |
  #        SUMMARY=$(echo $JOB_RESULTS | jq 'to_entries[] | .key + ": " + .value.result' | tr -d '"')
  #        echo 'ðŸ¤–: CICD Result for test level: ${{ needs.pre-flight.outputs.test_level }}' >> $GITHUB_STEP_SUMMARY
  #        echo "$SUMMARY" >> $GITHUB_STEP_SUMMARY

  #        if [[ "$TEST_LEVEL" == "none" ]]; then
  #          echo "No tests were run, passing gate" >> $GITHUB_STEP_SUMMARY
  #          exit 0
  #        fi

  #        test "$ALL_SUCCESS" = "true" || test "$CI_SKIP" = "true"

  #DCO_merge_group:
  #  name: DCO
  #  if: github.event_name == 'merge_group'
  #  runs-on: ubuntu-latest
  #  steps:
  #    - run: echo "The real DCO check happens on PRs only. This is a placeholder for the merge queue to keep the DCO check as a required status check."
